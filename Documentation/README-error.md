# Error Handling in SwiftSDL

SwiftSDL provides a structured and idiomatic Swift interface for handling errors emitted by the underlying C-based SDL library. By wrapping SDL's error-handling mechanisms, SwiftSDL makes it easier to identify, manage, and respond to issues in your applications while maintaining Swift's safety and expressiveness.

---

## Overview

In the SDL library, errors are typically retrieved using the `SDL_GetError()` function, which provides a string description of the most recent error. SwiftSDL encapsulates this behavior in a Swift-native `SDL_Error` type, which conforms to the `Error` protocol. This allows you to seamlessly work with SDL errors using Swift's `do-catch` syntax.

### Key Features

- All errors emitted by SDL are wrapped in the `SDL_Error` type.
- Descriptive messages are captured from SDL's internal error system.
- Error creation and propagation align with Swift’s `Result` and `do-catch` paradigms.
- Explicit error-checking APIs simplify handling specific SDL function failures.

---

## `SDL_Error` Type

### Declaration

```swift
public enum SDLError: Error, CustomDebugStringConvertible, @unchecked Sendable {
  case error
  case custom(_ message: String)
  case customWithArgs(_ fmt: String, _ args: [CVarArg])
}
```

### Properties

#### `error`

Returns the most recent error returned by `SDL_GetError`.

#### `custom`

Invokes `SDL_SetError` with the provided message.

| Property   | Type   | Description                                                  |
|------------|--------|--------------------------------------------------------------|
| `message`  | String | The error message generated by SDL (via `SDL_GetError()`).   |

#### `customWithArgs`

Invokes `SDL_SetErrorV` with the provided message.

| Property   | Type   | Description                                                  |
|------------|--------|--------------------------------------------------------------|
| `fmt`  | String | A formatted C-String message provided by the developer.   |
| `args` | String | A variadic arguments associated with the `fmt` string. |

---

## Generating Errors

Errors are generated when SDL functions return failure codes (e.g., `-1`, `false`, or `NULL` pointers). SwiftSDL wraps these failures and captures the error message for further handling.

Instances of `SDLObjectProtocol` can call SDL functions which may return failure codes using `try`:

```swift
// You can use SDL functions as arguments.
// If you necessary, wrap these in a do-catch.

/* 1.  Minimizes the window. */
try window(SDL_MinimizeWindow)

/* 2a.  Clear the rendering target to green; draw blue point; present it.  */
try renderer(SDL_SetRenderDrawColor, 0x00, 0xFF, 0x00, 0xFF)
try renderer(SDL_RenderClear)
try renderer(SDL_SetRenderDrawColor, 0x00, 0x00, 0xFF, 0xFF)
try renderer(SDL_RenderPoint, 100, 100)
try renderer(SDL_RenderPresent)

/* 2b.  Alternative to 2a. using function chaining. */
try renderer
  .clear(color: .green)
  .points([100, 100], color: .blue)
  .present()
```

---

## Debugging SDL Errors

As discussed, SwiftSDL automatically lifts errors from `SDL_GetError`. SwiftSDL outputs the last unhandled error to help aid debugging.

Consider this example:

```bash
➜ swift run sdl test sandbox --window-maximized
Building for debugging...
onInit: A window without the 'SDL_WINDOW_RESIZABLE' flag can't be maximized
```

> **Note:** _This exact error can be avoided by running the program with the `--window-resizable` flag._

---

## Common API Patterns

SwiftSDL provides APIs that return `Result` types, typically with `SDL_Get_______` functions which can fail.

```swift
/* 1a.  Get the window's title using `resultOf`. */
switch window
  .resultOf(SDL_GetWindowTitle)
  .map(String.init(cString:))
{
  case .success(let title): print(title)
  case .failure(let error): print(error)
}

/* 1b.  Get the window's title using the property */
switch window.title {
  case .success(let title): print(title)
  case .failure(let error): print(error)
}
```

---

## Example: Full Error Handling in a Game Loop

```swift
import SwiftSDL


final class MyGame: Game {
  enum CodingKeys: String, CodingKey {
    case options
    case haltOnStartup
  }
  
  @OptionGroup var options: Options

  @Flag var haltOnStartup: Bool = true
  
  private var renderer: (any Renderer)! = nil
  private var icon:     (any Texture)?  = nil

  func onReady(window: any SwiftSDL.Window) throws(SwiftSDL.SDL_Error) {
    // Based on this example, it makes sense that
    // errors here should halt the program.
    renderer = try window.createRenderer()
    
    // Any errors thrown have been handled by the developer.
    do {
      let icon = try renderer.texture(from: try Load(bitmap: "icon.bmp"))
      try icon.set(blendMode: blendMode)
      
      self.icon = icon
    }
    catch {
      print("Unable to load bitmap. Ignoring texture rendering.")
    }
    
    // Signal that 'onReady' has failed for non-SDL reasons
    // by throwing a custom error.
    guard haltOnStartup == false else {
      throw .custom("Aborting game. Set --halt-on-startup to disable")
    }
  }
  
  func onUpdate(window: any Window, _ delta: Uint64) throws(SDL_Error) {
    /* update game state; draw to renderer */
  }

  func onEvent(window: any Window, _ event: SDL_Event) throws(SDL_Error) {
    /* no-op */
  }
  
  func onShutdown(window: (any Window)?) throws(SDL_Error) {
    /* clean-up */
    icon = nil
    renderer = nil
  }
}
```

In this example, possible errors may occur which will halt the program:

  1. if creating the window's renderer fails; or,
  2. if the bitmap isn't found, or fails to load; or,
  3. if setting the texture's color modifier goes wonky.

This example shows how to handle errors effectively by initializing SDL:
          
- Decide if unhandled SDL errors should stop your program, based on your specific requirements.
- If needed, throw a custom error to manually stop the game loop.  

---

By integrating SwiftSDL's error-handling features into your applications, you can write robust, maintainable, and safe code while leveraging SDL's powerful multimedia capabilities.
